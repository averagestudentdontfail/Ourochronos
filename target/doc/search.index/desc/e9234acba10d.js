rd_("AnEqual. Stack: ( a b \xe2\x80\x93 a==b )BgGreater than. Stack: ( a b \xe2\x80\x93 a&gt;b )CnStructured IF statement. Pops the condition from stack; if \xe2\x80\xa6BdLess than. Stack: ( a b \xe2\x80\x93 a&lt;b )AjContains the success valueAhExecute a single opcode.BbBitwise OR. Stack: ( a b \xe2\x80\x93 a|b )jUnique ID.C`Virtual Machine for OUROCHRONOS epoch execution.B`Addition. Stack: ( a b \xe2\x80\x93 a+b )BgBitwise AND. Stack: ( a b \xe2\x80\x93 a&amp;b )CnDivision (returns 0 if divisor is 0). Stack: ( a b \xe2\x80\x93 a/b \xe2\x80\xa6C`Duplicate the top of stack. Stack: ( a \xe2\x80\x93 a a )AhContains the error valueoGit repository.CaGreater than or equal. Stack: ( a b \xe2\x80\x93 a&gt;=b )BnLess than or equal. Stack: ( a b \xe2\x80\x93 a&lt;=b )CjModulo (returns 0 if divisor is 0). Stack: ( a b \xe2\x80\x93 a%b )BfMultiplication. Stack: ( a b \xe2\x80\x93 a*b )CbNegation (two\xe2\x80\x99s complement). Stack: ( a \xe2\x80\x93 -a )BbNot equal. Stack: ( a b \xe2\x80\x93 a!=b )mNo operation.B`Bitwise NOT. Stack: ( a \xe2\x80\x93 ~a )BaThe one value with no provenance.CbPop and discard the top of stack. Stack: ( a \xe2\x80\x93 )CiRotate the top three elements. Stack: ( a b c \xe2\x80\x93 b c a )BiLeft shift. Stack: ( a n \xe2\x80\x93 a&lt;&lt;n )CdRight shift (logical). Stack: ( a n \xe2\x80\x93 a&gt;&gt;n )BcSubtraction. Stack: ( a b \xe2\x80\x93 a-b )BcBitwise XOR. Stack: ( a b \xe2\x80\x93 a^b )C`Ahead-of-Time (AOT) compilation for OUROCHRONOS.BeAbstract Syntax Tree for OUROCHRONOS.CiLexicographic comparison of memory states by cell values.CiDivision with zero-divisor handling per specification \xe2\x80\xa6AeGet a module by name.BfLook up a cached result by state hash.C`JIT compilation for OUROCHRONOS using Cranelift.BeGet the total number of memory cells.A`Length in bytes.CaLanguage Server Protocol support for OUROCHRONOS.BhCreate a new module with the given name.AlCreate a new empty registry.C`Create a new AOT compiler for the host platform.AjCreate a new JIT compiler.AfCreate a new analyzer.BfCreate a new value with no provenance.CeCreate a new memory state with all cells set to zero.AhCreate an empty program.BgCreate a new parser from a token slice.AbCreate a new span.AkCreate a new spanned token.AiCreate a new parse error.CaCreate a new executor with default configuration.BcCreate a new VM state for an epoch.C`Create a new time loop with given configuration.AeCreate a new encoder.BoCreate a new generator with the given strategy.CiCreate a new selector with the given action principle \xe2\x80\xa6BbCreate a new empty provenance map.ChCreate an action principle with the given configuration.AgCreate a new candidate.AjCreate a new type checker.AiCreate a new empty cache.AkCreate a new delta tracker.BlCreate a new optimizer with the given level.AmCreate with custom threshold.BfCreate a new REPL with default config.AfCreate a new debugger.AmCreate a new package manager.CnModulo with zero-divisor handling per specification \xc2\xa75.3: \xe2\x80\xa6AkRun the fixed-point search.AiRun the interactive REPL.AkRun program with debugging.BdThe numeric value (64-bit unsigned).CiCall a procedure by name. Stack effect depends on the \xe2\x80\xa6BnFull optimizations including pattern matching.CcHalt execution of the current epoch. Stack: ( \xe2\x80\x93 )AaNo optimizations.CnCopy the second element to the top. Stack: ( a b \xe2\x80\x93 a b a \xe2\x80\xa6CiPack n values into contiguous memory starting at base \xe2\x80\xa6CnPick the nth element from deep in the stack and copy it to \xe2\x80\xa6CkProcedure is pure (no side effects, deterministic given \xe2\x80\xa6BhUnbounded iteration (may not terminate).CjValue has no temporal dependency (constant, ground truth).BePush a constant value onto the stack.BaInteractive REPL for OUROCHRONOS.BiSource location span for error reporting.AmOriginal statement (unfused).BcA statement in the OUROCHRONOS AST.CaSwap the top two elements. Stack: ( a b \xe2\x80\x93 b a )AoA word (identifier or keyword).BbThe zero value with no provenance.AlAll zeros (classic default).BeBase address for the isolated region.AfBody of the procedure.AbMain program body.AkBody of the temporal scope.CnThe set of anamnesis addresses this value depends on. None \xe2\x80\xa6CiFind addresses where values differ between two memory \xe2\x80\xa6nEvaluate code.AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000AcOptional help text.AeNumber of cache hits.CbInitialize a new package in the current directory.BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000ChIterate over all cells, yielding (address, value) pairs.CjJoin two types in the lattice. Temporal \xe2\x8a\x94 anything = \xe2\x80\xa6eKind.AhLine number (0-indexed).AhLine number (1-indexed).lLine number.AhList installed packages.A`Main entry file.CbMemoization and caching for OUROCHRONOS execution.oExecution mode.lModule name.CiGet the name of this opcode as it appears in source code.oProcedure name.AdHuman-readable name.mPackage name.0CdCreate provenance with no temporal dependency (\xe2\x8a\xa5).nOptional note.AnResolved path (after install).CiCausal provenance (which oracle cells influenced this \xe2\x80\xa6BdRead the value at the given address.BlREPL (Read-Eval-Print-Loop) for OUROCHRONOS.BkInitial seed for anamnesis (0 = all zeros).BfThe seed that led to this fixed point.AfGet the size in bytes.AlSize of the isolated region.AkNumber of entries in cache.A`Source location.BeSource location where error occurred.CcBasic instruction fusion (combine consecutive ops).BhA block of statements (scoped grouping).B`Block of optimized instructions.ClClear pattern: set memory cell to zero. Detects patterns \xe2\x80\xa6hComma: ,BnPush the current stack depth. Stack: ( \xe2\x80\x93 n )BfEpoch terminated due to runtime error.AoRuntime error during execution.CnRead from memory at computed index: base + index. Stack: ( \xe2\x80\xa6BmRead a value from input. Stack: ( \xe2\x80\x93 value )AfLocal filesystem path.CgPattern match on top-of-stack value. Pops value and \xe2\x80\xa6CaProcedure reads from the specific oracle address.CmStore to memory at computed index: base + index. Stack: ( \xe2\x80\xa6AmTokens produced by the lexer.ChA value in OUROCHRONOS: 64-bit unsigned integer with \xe2\x80\xa6CmStructured WHILE loop. Evaluates cond block, pops result; \xe2\x80\xa6CeBuild TDG from a program via abstract interpretation.AfRaw object file bytes.AnList of (pattern, body) pairs.AfAddresses in the loop.AkCells involved in the loop.AeType-check a program.A`Clear the cache.AgCycle of memory states.AmEpoch where paradox occurred.mEpoch number.AoInput values (simulated input).lLabel shown.CiMerge two provenances (lattice join: \xe2\x8a\x94). The result \xe2\x80\xa6BkMerge another provenance map into this one.BjParse source code directly into a program.AlReset the iteration counter.AaReset statistics.AbThe operand stack.AgCompilation statistics.AcCompile statistics.AeGet cache statistics.AlGet optimization statistics.jThe token.BiCompile-time type system for OUROCHRONOS.BcWrite a value to the given address.BjCopy value: copy from one cell to another.AjUser-provided custom seed.BdSide effect behavior of a procedure.AfEquals sign for LET: =BbValue must equal a specific value.mLeft brace: {AcLeft parenthesis: (AoA snapshot of the memory state.AdA module definition.AbA numeric literal.BhAll operations available in OUROCHRONOS.CnORACLE: Read from anamnesis (the future). Pops an address, \xe2\x80\xa6BdOutput a value. Stack: ( value \xe2\x80\x93 )B`Parser for OUROCHRONOS programs.nRight brace: }AdRight parenthesis: )BcRandom values in a specified range.AhStandard library module.CkUnpack n values from contiguous memory at base address. \xe2\x80\xa6CbProcedure writes to the specific prophecy address.BaComputed action (lower = better).CgAction Principle for OUROCHRONOS fixed-point selection.AjColumn number (0-indexed).AjColumn number (1-indexed).BgConfiguration for the action principle.lDetail text.AmEncode a program to SMT-LIB2.AmNumber of epochs to converge.BkNumber of epochs to reach this fixed point.AfAny type errors found.kGet events.AlStore a result in the cache.AlThe consistent memory state.AaThe memory state.AcGet current memory.AgNumber of cache misses.AnModule system for OUROCHRONOS.AfByte offset in source.nOutput buffer.BaOutput produced during the epoch.A`Output produced.BaOutput produced during execution.11ClParameter names (for documentation; all params come from \xe2\x80\xa6BaLexer and Parser for OUROCHRONOS.mCycle period.nPrompt string.CgCreate provenance depending on a single anamnesis cell.A`Source location.AaExecution status.A`Terminal status.AdStatus of execution.gStatus.BaStandard Library for OUROCHRONOS.nTarget triple.BgAddress type (16-bit index into memory)AnMemory address (16-bit index).AdA character literal.BbValue must be in range [min, max].AgValue must be non-zero.AcA resolved package.CjPARADOX: Signal explicit inconsistency. Terminates the \xe2\x80\xa6CeEpoch terminated due to explicit PARADOX instruction.BeExplicit PARADOX instruction reached.AaParadox detected.AoA complete OUROCHRONOS program.AgEpoch is still running.A`Stack operation.BhEpoch limit reached without convergence.nUnknown cause.BkType is not yet determined (for inference).C`Complete state of the VM during epoch execution.AeAddress to constrain.BkAnalyze source code and return diagnostics.hAuthors.CkCompare two fixed points and return which is preferred. \xe2\x80\xa6BdCompile a program to an object file.BaCompile a program to native code.BlCompute the action (cost) of a memory state.AkGet current epoch snapshot.BcDefault case if no pattern matches.BhEffect annotations declared by the user.hEnabled.BlExecute the compiled function (placeholder).AdExported procedures.AbGet all snapshots.AjInstall a package by name.BgCheck if this value is temporally pure.CeCheck if this value is temporally pure (no oracle \xe2\x80\xa6hMessage.nError message.AcDiagnostic message.AiDescription of the error.ClCreate a configuration that prefers minimal computation. \xe2\x80\xa6B`Package Manager for OUROCHRONOS.BnPresent memory (being constructed this epoch).AiThe final present memory.AlThe resulting present state.AcMemory after epoch.BhNumber of return values pushed to stack.BoConvert to boolean (0 = false, nonzero = true).AjWhether to print progress.AdShow verbose output.oVersion string.AcVersion constraint.BaStatistics about AOT compilation.AeTime-travel debugger.CeValue must be distinct from other constrained values.oEpoch finished.BiThe OUROCHRONOS virtual machine executor.BoEpoch completed normally (reached end or HALT).CcFused addition: add N to top of stack. Replaces \xe2\x80\xa6AoError type for JIT compilation.BeOptimized instruction representation.BdOptimization level for the compiler.BgStatistics about optimizations applied.CjParallel exploration of multiple seeds simultaneously. \xe2\x80\xa6ClPROPHECY: Write to present (fulfilling the future). Pops \xe2\x80\xa6mRegistry URL.AhLSP diagnostic severity.BeBasic iteration with cycle detection.BjValue depends on at least one oracle read.AiThe temporal loop driver.BiStatic analysis for OUROCHRONOS programs.AkCheck if a state is cached.AdContent in markdown.BeTime-Travel Debugger for OUROCHRONOS.iEnd line.ChCreate provenance depending on multiple anamnesis cells.AfHit rate (0.0 to 1.0).BeCheck if memory is empty (all zeros).AkCheck if function is valid.BbWhether the program is well-typed.B`Location hint (statement index).iManifest.AcOptimize a program.iOptional.AbRegister a module.iSeverity.CdFixed-point computation and temporal loop execution.BoTokenize source code into a sequence of tokens.AlWarnings (non-fatal issues).CjCanonical chronology: action first, then lexicographic \xe2\x80\xa6AhDirection of divergence.AbHover information.AjResult of JIT compilation.CdSelect by minimum action only (non-deterministic \xe2\x80\xa6CiPrefer faster convergence: action first, then minimum \xe2\x80\xa6CmMove until zero: scan memory in a direction until finding \xe2\x80\xa6CjOptimizer that transforms programs for better performance.AgA procedure definition.BfSemicolon for statement termination: ;AaA string literal.AkType error during checking.CdAnamnesis memory (read-only, from the \xe2\x80\x9cfuture\xe2\x80\x9d).AdMemory before epoch.AdGet cache directory.B`Size of generated code in bytes.AeCondition (optional).AiDiagnosis of the paradox.AhDirection of divergence.BhGet current execution count for a block.AfGet hover information.BdGenerate the next seed memory state.BaNumber of different seeds to try.AkNumber of seeds to explore.BmOptimization passes for OUROCHRONOS programs.B`Run a single epoch of execution.AbStep back in time.nAdd help text.iAdd note.CaCreate a selector with a specific selection rule.AbAdd span to error.kBreakpoint.BcStatistics about cache performance.AiFixed point found: P = A.CeConstraint-based: satisfy PREFER/REQUIRE annotations.AbDebug event types.AkA dependency specification.BgFull trajectory recording and analysis.AeA diagnostic message.CaDivergence detected (monotonic unbounded growth).BbCache for memoizing epoch results.nEpoch started.AbFixed point found.lMemory read.AjResult of AOT compilation.BnParse error with location and helpful message.CkProvenance tracks which anamnesis cells a value depends on.AcREPL configuration.BaSMT-LIB2 encoder for OUROCHRONOS.CjGet all candidates sorted according to the selection rule.B`Inferred types for memory cells.A`Constraint type.BoCore types for the OUROCHRONOS virtual machine.kEnd column.AjNumber of fused additions.AgJump to specific epoch.AnMaximum epochs before timeout.AiMaximum epochs attempted.AnMaximum epochs per evaluation.BeAll procedures defined in the module.AfProcedure definitions.BdGet all standard library procedures.CcProvenance tracking for causal dependency analysis.kSet memory.BhCheck if a block should be JIT compiled.CeGet a hash of the memory state (for cycle detection).BkType-check a program and return the result.BcCreate with custom cache directory.BhAOT compiler that produces object files.AlCranelift compilation error.BcResult of executing a single epoch.AjStatus of epoch execution.CdFused memory operations: N consecutive reads/writes.BdIncremental sequence (2, 3, 4, \xe2\x80\xa6).BfJIT compiler for OUROCHRONOS programs.CbThe size of the memory space (2^16 = 65536 cells).mMemory write.BnOscillation detected (cycle of length &gt; 1).AdGeneral oscillation.CkPRESENT_READ: Read from present memory (current epoch). \xe2\x80\xa6BlSmall primes (optimized for factor-finding).BfType checker for OUROCHRONOS programs.AfUnsupported operation.A`Get breakpoints.AeGet cache statistics.lDescription.BgCompare two epochs (show what changed).AkHuman-readable explanation.0CdBias toward small primes for factorization problems.lInsert text.BaCheck if a procedure is exported.C`Check if this value has any temporal dependency.BjCheck if a cell has any oracle dependency.AhLoad a module from file.BmNumber of parallel workers (0 = auto-detect).AfNumber of relocations.CjSelect the best candidate according to the selection rule.BbShow memory after each evaluation.BjSMT-LIB2 encoder for OUROCHRONOS programs.AaSource file path.CcExpected value range based on constants in program.BmCreate an executor with custom configuration.AjCreate with custom config.BgConfiguration for the action principle.CkAction-guided search: explore multiple seeds and select \xe2\x80\xa6BaStatistics about JIT compilation.AoIncremental computation helper.BkNegative causal loop (grandfather paradox).CeA negative causal loop (grandfather paradox pattern).CjSeed generation strategy for constraint-based seeding. \xe2\x80\xa6AmA token with its source span.BoTemporal type for compile-time causal tracking.CjCreate a configuration that strongly penalizes trivial \xe2\x80\xa6CkBonus (negative penalty) for each unit of causal depth. \xe2\x80\xa6CmGet the causal depth of a cell (0 = pure constant, higher \xe2\x80\xa6BoGet the set of addresses this value depends on.mDependencies.AjCheck if AOT is available.AjCheck if JIT is available.BiCheck if states are identical (no delta).CjIterate over non-zero cells, yielding (address, value) \xe2\x80\xa6AlList all registered modules.CgBonus for output-producing fixed points. Encourages \xe2\x80\xa6CiPenalty applied for cells with no temporal dependency \xe2\x80\xa6BhGet the stack effect: (inputs, outputs).AeStep forward in time.ClCheck if two memory states are equal (by value, ignoring \xe2\x80\xa6CkPenalty applied for each cell that is zero (trivial value).oBreakpoint hit.AoEpoch snapshot for time-travel.oExecution mode.AhPackage source location.CjTracks causal depth and provenance for action computation.CbGenerator for producing seeds based on a strategy.ChSelection rule for choosing among equal-action fixed \xe2\x80\xa6BiTemporal scope block. TEMPORAL   { body }AlAdd a candidate fixed point.CmCompare candidates using canonical ordering (action, then \xe2\x80\xa6ClCompute the delta between two memory states. Returns the \xe2\x80\xa6BgDisplay type information for a program.BeGet documentation for all procedures.BfFormat convergence status for display.CjPre-specified inputs (frozen). If non-empty, these are \xe2\x80\xa6BbNumber of fused memory operations.BbGet an exported procedure by name.CaCheck if this type is more specific than another.BiLoad a package manifest from a directory.BfParse EXPORT declarations from source.AiParse a complete program.CeFind the temporal core: addresses in feedback cycles.BkCreate a cache with pre-allocated capacity.AnWrite the object file to disk.AhA completion suggestion.AeCompletion item kind.BaTypes of constraints for seeding.AoConfiguration for the executor.BiThe result of a memoized epoch execution.BlModule registry for tracking loaded modules.A`Package manager.BaA constraint for seed generation.CiTiered execution: decides whether to interpret or JIT \xe2\x80\xa6B`Configuration for the time loop.oAdd breakpoint.BbCreate with default configuration.CkWeight for entropy (diversity of values). Higher values \xe2\x80\xa6BbGenerate a batch of diverse seeds.CnCompare candidates using min-epochs ordering (action, then \xe2\x80\xa6AhFind all non-zero cells.BkNumber of instructions before optimization.CiThe Action calculator for evaluating fixed-point quality.AdFeature not enabled.BjConfiguration for heuristic-based seeding.AaPackage metadata.AhResult of type checking.BhAdd a search path for module resolution.AmGet the number of candidates.AcCells that diverge.AnGet completions at a position.CkInput values consumed during this epoch. Used for input \xe2\x80\xa6BjNumber of instructions after optimization.AjCalculate reduction ratio.B`Get causality chain for a value.BhCreate a value with explicit provenance.CnCreate a configuration optimized for factorization/witness \xe2\x80\xa6B`A compiled OUROCHRONOS function.BfOUROCHRONOS language analyzer for LSP.BdDiagnosis of why a paradox occurred.BaCount the number of dependencies.BdWhether to print output immediately.BkMaximum instructions per epoch (gas limit).BnBias toward permutations for sorting problems.AmResult of fixed-point search.AmStack type at end of program.CiInline all procedure calls, replacing Stmt::Call with \xe2\x80\xa6AiAddresses that oscillate.CaNumber of patterns detected (Clear, CopyTo, etc).AbRemove breakpoint.CeResolve a qualified name (module::procedure) to a \xe2\x80\xa6CmPenalty for cells that have the same value as their seed. \xe2\x80\xa6BkCreate an encoder with custom unroll limit.CdSelector for choosing among multiple fixed-point \xe2\x80\xa6CfCollect all provenance information from written cells.AmNumber of functions compiled.0CjInfer the best seed strategy from program characteristics.AmNumber of opcodes translated.EaRecord that <code>addr</code> was computed from <code>sources</code> via some \xe2\x80\xa6CaA candidate fixed point with its computed action.CcAnalyze a program and return negative loops if any.CnFind negative causal loops (grandfather paradox patterns). \xe2\x80\xa6CeCreate boolean value (1 or 0) with merged provenance.BcGet oracle dependencies for a cell.BiNumber of unsupported operations skipped.CjBuild provenance map from a value\xe2\x80\x99s embedded provenance.BeInstruction count (for gas limiting).B`Number of instructions executed.AjTemporal Dependency Graph.BkCheck if a program is trivially consistent.CiCheck if a program is trivially consistent (no feedback).CkCheck if the program is trivially consistent (no oracle \xe2\x80\xa6BeParse MODULE declaration from source.DiRecord that a value at <code>addr</code> was derived from oracle read \xe2\x80\xa6")