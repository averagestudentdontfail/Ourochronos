# OUROCHRONOS

> "Time is not a line, but a circle; causality swallows its own tail."

**Ourochronos** is a stack-based, retrocausal programming language where execution is a search for a self-consistent timeline. In Ourochronos, programs do not merely calculate outputs from inputs; they receive information from the future and must act to ensure that information was correct.

## The Generative Insight

What would programming look like if we took **Closed Timelike Curves (CTCs)** seriously as a computational model?

Ourochronos answers this by implementing **Deutschian CTC semantics**: a program is valid if and only if its execution state at the "end" of time is identical to the state it assumed at the "start" of time. Running a program means finding a **Fixed Point** in the state space.

$$ S_{final} = Program(S_{initial}) \implies S_{initial} = S_{final} $$

## Philosophy

The name fuses two Greek roots:
*   **Ouroboros** (οὐροβόρος): The serpent devouring its own tail. Symbol of excessive return and self-reference.
*   **Chronos** (Χρόνος): The personification of sequential, measurable time.

**Ourochronos** implies "time consuming itself". It challenges the fundamental assumption of disparate cause and effect. In this language, the future causes the past just as much as the past causes the future.

## Installation

```bash
cargo install --path .
```

## Usage

### Run a Program
```bash
ourochronos program.ouro
```

### Diagnostic Mode
Trace the causality of a paradox or loop.
```bash
ourochronos program.ouro --diagnostic
```

### SMT Verification
Compile your timeline constraints to SMT-LIB2 logic to prove validity or impossibility without running it.
```bash
ourochronos program.ouro --smt > constraints.smt2
z3 constraints.smt2
```

## Key Features

### 1. Retrocausal Computation
Use `ORACLE` to read from the future and `PROPHECY` to write to the past.
```ourochronos
0 ORACLE          ; Read value from Future[0]
DUP 1 ADD         ; Calculate Value + 1
0 PROPHECY        ; Write to Past[0]
; Result: DIVERGENCE (x = x + 1 has no fixed point)
```

### 2. Paradox Detection
The runtime detects **Grandfather Paradoxes** (oscillating states) and **Divergence** (infinite growth).
```ourochronos
0 ORACLE NOT 0 PROPHECY
; Result: OSCILLATION (Cell 0 flips between 0 and 1)
```

### 3. Formal Verification
The language includes a built-in SMT compiler that translates temporal logic into static constraints, allowing you to use solvers like Z3 to find fixed points for complex programs instantly.

### 4. Action Principle
When multiple fixed points exist, Ourochronos can find the "path of least resistance" - a trivial solution. The **Action Principle** addresses this by defining a cost function analogous to the Lagrangian in physics:

```bash
ourochronos program.ouro --action
```

In `--action` mode, the runtime:
1. Explores multiple seed strategies (zeros, primes, sequences, etc.)
2. Finds all valid fixed points
3. Selects the one with **minimum action** (preferring non-trivial, output-producing solutions)

This mirrors how the Principle of Least Action in physics selects the actual path from infinite possibilities.

## Documentation
*   [Formal Specification](docs/specification.md): The Abstract Machine and ISA.
*   [Coding Standard](docs/standard.md): Governance for Causal Integrity.
*   [Theoretical Foundations](docs/theory.md): Advanced design, mathematics and proofs.

## Example: Time Travel Primality Test
Instead of searching for a factor, we ask the future for the answer and merely verify it.
```ourochronos
; Ask future for a factor of 15
0 ORACLE
DUP
; Verify if it is a factor...
15 SWAP MOD 0 EQ
IF {
    ; It is a factor! Stabilize the timeline.
    0 PROPHECY
} ELSE {
    ; Wrong guess. Change the past to try a different number.
    1 ADD 0 PROPHECY
}
```
*Result: The timeline spontaneously stabilizes on `3`.*

---
*Generated by the Ourochronos Project.*
